#!/usr/bin/python -tt
# -*- coding: utf-8 -*-

###
###  logster
###
###  Tails a log and applies a log parser (that knows what to do with specific)
###  types of entries in the log, then reports metrics to Zabbix and/or Graphite.
###
###  Usage:
###
###    $ logster [options] parser logfile
###
###  Help:
###
###    $ logster -h
###
###
###  Copyright 2011, Etsy, Inc.
###
###  This file is part of Logster.
###  
###  Logster is free software: you can redistribute it and/or modify
###  it under the terms of the GNU General Public License as published by
###  the Free Software Foundation, either version 3 of the License, or
###  (at your option) any later version.
###  
###  Logster is distributed in the hope that it will be useful,
###  but WITHOUT ANY WARRANTY; without even the implied warranty of
###  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
###  GNU General Public License for more details.
###  
###  You should have received a copy of the GNU General Public License
###  along with Logster. If not, see <http://www.gnu.org/licenses/>.
###
###  Forked from the ganglia-logtailer project 
###  (http://bitbucket.org/maplebed/ganglia-logtailer):
###    Copyright Linden Research, Inc. 2008
###    Released under the GPL v2 or later.
###    For a full description of the license, please visit 
###    http://www.gnu.org/licenses/gpl.txt
###

import os
import sys
import re 
import optparse
import logging.handlers
import socket 
import traceback
import threading

from time import time, strftime, gmtime, sleep

# Local dependencies
from logster.logster_helper import LogsterParsingException, SubmitException
from logster.tail import Tail

# Globals
log_dir = "/var/log/logster"


# Command-line options and parsing.
cmdline = optparse.OptionParser(usage="usage: %prog [options] parser logfile",
    description="Tail a log file and filter each line to generate metrics that can be sent to common monitoring packages.")
cmdline.add_option('--metric-prefix', '-p', action='store',
                    help='Add prefix to all published metrics. This is for people that may multiple instances of same service on same host.',
                    default='')
cmdline.add_option('--metric-suffix', '-x', action='store',
                    help='Add suffix to all published metrics. This is for people that may add suffix at the end of their metrics.',
                    default=None)
cmdline.add_option('--parser-help', action='store_true', 
                    help='Print usage and options for the selected parser')
cmdline.add_option('--parser-options', action='store', 
                    help='Options to pass to the logster parser such as "-o VALUE --option2 VALUE". These are parser-specific and passed directly to the parser.')
cmdline.add_option('--graphite-host', action='store',
                    help='Hostname and port for Graphite collector, e.g. graphite.example.com:2003')
cmdline.add_option('--zabbix-server', action='store',
                    help='Zabbix server Hostname, e.g. zabbix.example.com')
cmdline.add_option('--zabbix-host', action='store',
                    help='Zabbix items Host')
cmdline.add_option('--output', '-o', action='append',
                   choices=('graphite', 'zabbix', 'stdout'),
                   help="Where to send metrics (can specify multiple times). Choices are 'graphite', 'zabbix' or 'stdout'.")
cmdline.add_option('--stdout-separator', action='store', default="_", dest="stdout_separator",
                    help='Seperator between prefix/suffix and name for stdout. Default is \"%default\".')
cmdline.add_option('--dry-run', '-d', action='store_true', default=False,
                    help='Parse the log file but send stats to standard output.')
cmdline.add_option('--debug', '-D', action='store_true', default=False,
                    help='Provide more verbose logging for debugging.')
options, arguments = cmdline.parse_args()

if options.parser_help:
    options.parser_options = '-h'

if (len(arguments) != 2):
    cmdline.print_help()
    cmdline.error("Supply at least two arguments: parser and logfile.")
if not options.output:
    cmdline.print_help()
    cmdline.error("Supply where the data should be sent with -o (or --output).")
if 'graphite' in options.output and not options.graphite_host:
    cmdline.print_help()
    cmdline.error("You must supply --graphite-host when using 'graphite' as an output type.")
if 'zabbix' in options.output and not options.zabbix_server and not options.zabbix_host:
    cmdline.print_help()
    cmdline.error("You must supply --zabbix-host and --zabbix-server when using 'zabbix' as an output type.")

class_name = arguments[0]
if class_name.find('.') == -1:
    # If it's a single name, find it in the base logster package
    class_name = 'logster.parsers.%s.%s' % (class_name, class_name)
log_file   = arguments[1]


# Logging infrastructure for use throughout the script.
# Uses appending log file, rotated at 100 MB, keeping 5.
if (not os.path.isdir(log_dir)):
    os.mkdir(log_dir)
logger = logging.getLogger('logster')
formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s')
hdlr = logging.handlers.RotatingFileHandler('%s/logster.log' % log_dir, 'a', 100 * 1024 * 1024, 5)
hdlr.setFormatter(formatter)
logger.addHandler(hdlr)
logger.setLevel(logging.INFO)

if (options.debug):
    logger.setLevel(logging.DEBUG)

## This provides a lineno() function to make it easy to grab the line
## number that we're on (for logging)
## Danny Yoo (dyoo@hkn.eecs.berkeley.edu)
## taken from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/145297
import inspect
def lineno():
    """Returns the current line number in our program."""
    return inspect.currentframe().f_back.f_lineno

class MetricManager(object):
    '''This process should be used to start the thread that calls
    gmetric every so often.  It should get the period and data from the
    parser object'''
    def __init__(self, options):
        self.options = options

    def __call__(self, parser):
        period = parser.period

        # wait one period the first time (so we have something to report)
        sleep(period)

        while True:
            logger.debug("manager: starting")
            start = time()
            metrics = parser.get_state() 
            # submit the stats
            submit_stats(metrics, self.options)
            finish = time()
            runtime = finish - start
            sleep_time = period - runtime
            while( sleep_time <= 0 ):
                logger.info( "manager: calculation time is longer than period.  doubling period to %s." % (period * 2) )
                sleep_time += period
                period *= 2
                # tell the logtailer class that we're slowing period
                parser.period = period
            logger.debug( "manager: sleeping for %s" % sleep_time)
            sleep(sleep_time)

def submit_stats(metrics, options):

    if 'graphite' in options.output:
        submit_graphite(metrics, options)
    if 'stdout' in options.output:
        submit_stdout(metrics, options)
    if 'zabbix' in options.output:
        submit_zabbix(metrics, options)

def submit_stdout(metrics, options):
    for metric in metrics:
        if (options.metric_prefix != ""):
            metric.name = options.metric_prefix + options.stdout_separator + metric.name
        if (options.metric_suffix is not None):
            metric.name = metric.name + options.stdout_separator + options.metric_suffix
        print "%s %s %s" %(metric.timestamp, metric.name, metric.value)

def submit_graphite(metrics, options):
    if (re.match("^[\w\.\-]+\:\d+$", options.graphite_host) == None):
        raise Exception, "Invalid host:port found for Graphite: '%s'" % options.graphite_host

    if (not options.dry_run):
        host = options.graphite_host.split(':')
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host[0], int(host[1])))

    try:
        for metric in metrics:
    
            if (options.metric_prefix != ""):
                metric.name = options.metric_prefix + "." + metric.name
            if (options.metric_suffix is not None):
                metric.name = metric.name + "." + options.metric_suffix
    
            metric_string = "%s %s %s" % (metric.name, metric.value, metric.timestamp)
            logger.debug("Submitting Graphite metric: %s" % metric_)
    
            if (not options.dry_run):
                s.sendall("%s\n" % metric_string)
            else:
                print "%s %s" % (options.graphite_host, metric_string)
    finally:
        if (not options.dry_run):
            s.close()

def submit_zabbix(metrics, options):
    from logster.zbxsend import ZbxSend
    z = ZbxSend(options.zabbix_server)

    for metric in metrics:
        if (options.metric_prefix != ""):
            metric.name = options.metric_prefix + "_" + metric.name
        if (options.metric_suffix is not None):
            metric.name = metric.name + "_" + options.metric_suffix

        logger.debug("Submitting Zabbix metrics: %s %s %s" %(options.zabbix_host ,metric.name, metric.value))

        if (not options.dry_run):
            z.add(options.zabbix_host, str(metric.name), str(metric.value))
        else:
            print "%s %s" %(metric.name, metric.value)

    try:
        if (not options.dry_run):
            info = z.send()
            logger.info("Submit info: %s" % info)
    except SubmitException, e:
        logger.error("Submit error: %s" % e) 

def main():

    logger.info("Executing parser %s on logfile %s" % (class_name, log_file))

    # Import and instantiate the class from the module passed in.
    module_name, parser_name = class_name.rsplit('.', 1)
    module = __import__(module_name, globals(), locals(), [parser_name])
    parser = getattr(module, parser_name)(option_string=options.parser_options)

    # Get input to parse.
    try:
        input = Tail(log_file)
    except Exception, e:
        # I don't know when this exception will ever actually be triggered.
        logger.error("Failed to to get log data (line %s): %s" %(lineno(), e))
        sys.exit(1)

    # Launch metric caller thread
    submitter = threading.Thread(target=MetricManager(options), args=[parser])
    submitter.setDaemon(True)
    submitter.start()

    # Parse each line from input, then send all stats to their collectors.
    try:
        for line in input:
            try:
                if not submitter.isAlive():
                    raise Exception, 'submitter thread died'
                parser.parse_line(line)
            except LogsterParsingException, e:
                # This should only catch recoverable exceptions (of which there
                # aren't any at the moment).
                logger.error("Parsing exception caught at %s: %s" % (lineno(), e))
    except Exception, e:
        logger.error("Exception caught at %s: %s" % (lineno(), e))
        traceback.print_exc()
        sys.exit(1)

if __name__ == '__main__':
    main()
